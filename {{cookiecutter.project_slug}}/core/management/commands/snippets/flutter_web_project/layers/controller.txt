///
/// [Arquivo gerado automaticamente pelo AgtecCore ]
///

///
/// [Arquivo travado]
/// Para evitar que o arquivo seja reescrito acidentalmente, 
/// o mesmo encontra-se "travado", para destravar remova o # da linha abaixo.
/// 
/// #FileLocked
///


/// Os Métodos padrões gerados são:
///   Métodos da API
///     fecth() -> Recupera a lista de $ModelClass$.
///     reload() -> Recarrega a lista de $ModelClass$.
///     detail() -> Recupera os detalhes de um $ModelClass$.
///     post() -> Salva um novo $ModelClass$.
///     put() -> Atualiza os dados de um $ModelClass$.
///     delete() -> Deleta um $ModelClass$.
///


import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';

import '../../../core/app.logger.dart';
import '../models/$Model$.dart';
import '../services/$Model$.dart';
part '../states/$Model$.dart';

class $ModelClass$Controller extends Cubit<$ModelClass$State> {
  // late $ModelClass$ServiceInterface _service;
  $ModelClass$Model $ModelClassCamelCase$Model = $ModelClass$Model();
  List<$ModelClass$Model> $ModelClassCamelCase$List = <$ModelClass$Model>[];
  final _service = $ModelClass$Service();

  $ModelClass$Controller({$ModelClass$Model? $ModelClassCamelCase$Model}): super($ModelClass$Initial());

  Future<void> fetch() async {
    try {
      emit($ModelClass$ProcessState());
      $ModelClassCamelCase$List.clear();
      final result = await _service.fetch();
      if (result.isLeft) {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
        return;
      }
      $ModelClassCamelCase$List = result.right as List<$ModelClass$Model>;
      if($ModelClassCamelCase$List.isEmpty){
        emit(const $ModelClass$EmptyListState('Nenhum registro encontrado.'));
      }else{
        emit(
          $ModelClass$SuccessState(
            successMessage: 'Dados carregados com sucesso.',
            $ModelClassCamelCase$List: $ModelClassCamelCase$List,
            $ModelClassCamelCase$Model: $ModelClassCamelCase$Model,
          ),
        );
      }
    } catch (error, stackTrace) {
      AppLogger().erro('#controller_layer', error, stackTrace);
      emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
    }
  }

  Future<void> reload() async {
    try {
      emit($ModelClass$ProcessState());
      $ModelClassCamelCase$List.clear();
      final result = await _service.fetch();
      if (result.isLeft) {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
        return;
      }
      $ModelClassCamelCase$List = result.right as List<$ModelClass$Model>;
      if($ModelClassCamelCase$List.isEmpty){
        emit(const $ModelClass$EmptyListState('Nenhum registro encontrado.'));
      }else{
        emit(
          $ModelClass$SuccessState(
            successMessage: 'Dados carregados com sucesso.',
            $ModelClassCamelCase$List: $ModelClassCamelCase$List,
            $ModelClassCamelCase$Model: $ModelClassCamelCase$Model,
          ),
        );
      }
    } catch (error, stackTrace) {
      AppLogger().erro('#controller_layer', error, stackTrace);
      emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar recarregar os dados.'));
    }
  }

  Future<void> post($ModelClass$Model $ModelClassCamelCase$) async {
    try {
      emit($ModelClass$ProcessState());
      final result = await _service.post(data: $ModelClassCamelCase$);
      if (result.isLeft) {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
        return;
      }
      $ModelClassCamelCase$Model = result.right as $ModelClass$Model;
      $ModelClassCamelCase$List.add($ModelClassCamelCase$Model);
      emit($ModelClass$SuccessState(
          successMessage: '$ModelClass$ cadastrado com sucesso.',
          $ModelClassCamelCase$List: $ModelClassCamelCase$List,
          $ModelClassCamelCase$Model: $ModelClassCamelCase$Model,
        ),
      );
    } catch (error, stackTrace) {
      AppLogger().erro('#controller_layer', error, stackTrace);
      emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar salvar.'));
    }
  }

  Future<void> put($ModelClass$Model $ModelClassCamelCase$) async {
    try {
      emit($ModelClass$ProcessState());
      final result = await _service.put(data: $ModelClassCamelCase$);
      if (result.isLeft) {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
        return;
      }
      $ModelClassCamelCase$Model = result.right as $ModelClass$Model;
      final index = $ModelClassCamelCase$List.indexWhere((element) => element.id == $ModelClassCamelCase$Model.id);
      if (index != -1) {
        $ModelClassCamelCase$List[index] = $ModelClassCamelCase$Model;
      }
      emit($ModelClass$SuccessState(
          successMessage: '$ModelClass$ atualizado com sucesso.',
          $ModelClassCamelCase$List: $ModelClassCamelCase$List,
          $ModelClassCamelCase$Model: $ModelClassCamelCase$Model,
        ),
      );
    } catch (error, stackTrace) {
      AppLogger().erro('#controller_layer', error, stackTrace);
      emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar atualizar.'));
    }
  }

  Future<void> patch($ModelClass$Model $ModelClassCamelCase$) async {
    try {
      emit($ModelClass$ProcessState());
      final result = await _service.patch(data: $ModelClassCamelCase$);
      
      if (result.isLeft) {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
        return;
      }
      $ModelClassCamelCase$Model = result.right as $ModelClass$Model;
      final index = $ModelClassCamelCase$List.indexWhere((element) => element.id == $ModelClassCamelCase$Model.id);
      if (index != -1) {
        $ModelClassCamelCase$List[index] = $ModelClassCamelCase$Model;
      }
      emit($ModelClass$SuccessState(
          successMessage: '$ModelClass$ atualizado com sucesso.',
          $ModelClassCamelCase$List: $ModelClassCamelCase$List,
          $ModelClassCamelCase$Model: $ModelClassCamelCase$Model,
        ),
      );
    } catch (error, stackTrace) {
      AppLogger().erro('#controller_layer', error, stackTrace);
      emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar atualizar.'));
    }
  }

  Future<void> delete($ModelClass$Model $ModelClassCamelCase$) async {
    try {
      emit($ModelClass$ProcessState());
      final result = await _service.delete(id: $ModelClassCamelCase$.id);

      if (result.isLeft) {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar consultar os dados.'));
        return;
      }

      if(result.right == true){
        $ModelClassCamelCase$List.removeWhere((element) => element.id == $ModelClassCamelCase$.id);
        emit(
          $ModelClass$SuccessState(
            successMessage: '$ModelClass$ excluído com sucesso.',
            $ModelClassCamelCase$List: $ModelClassCamelCase$List,
            $ModelClassCamelCase$Model: $ModelClassCamelCase$Model,
          ),
        );
      } else {
        emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar excluir o registro.'));
      }
    } catch (error, stackTrace) {
      AppLogger().erro('#controller_layer', error, stackTrace);
      emit(const $ModelClass$ErrorState('Ocorreu um erro ao tentar excluir o registro.'));
    }
  }
}
