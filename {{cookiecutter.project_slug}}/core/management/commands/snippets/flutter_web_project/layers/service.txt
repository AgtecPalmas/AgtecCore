///
/// [Arquivo gerado automaticamente pelo NuvolsCore ]
///

///
/// [Arquivo travado]
/// Para evitar que o arquivo seja reescrito acidentalmente, 
/// o mesmo encontra-se "travado", para destravar remova o # da linha abaixo.
/// 
/// #FileLocked
///

///
/// Service do model $ModelClass$
/// 
/// Os Métodos padrões gerados são:
/// 
///     fetch()    -> Recupera a lista de $ModelClass$ da API.
///     getMore()  -> Recupera mais itens de $ModelClass$ da API.
///     detail()   -> Recupera os detalhes de $ModelClass$ da API.
///     post()     -> Salva os dados de uma instância do $ModelClass$ na API.
///     patch()    -> Atualiza os dados de uma instância do $ModelClass$ na API.
///     put()      -> Atualiza os dados de uma instância do $ModelClass$ na API.
///     delete()   -> Deleta os dados de uma instância do $ModelClass$ na API.
///
/// Os métodos de acesso à API devem ser implementados nessa classe.
/// 

import 'dart:convert';


import 'package:either_dart/either.dart';
import '/core/app.config.dart';
import '/core/app.dependencies.injection.dart';
import '/core/dio/app_dio.dart';
import '/core/interfaces/http.dart';
import '../models/$Model$.dart';


class $ModelClass$Service implements HttpInterface {
  final String _uri = '${Config.uri}api/v1/$App$s/$ModelSnakeCase$/';

  // Recuperando o Dio pelo getIt
  final AppDio _dio = getIt<AppDio>();

  @override
  Future<Either<Exception, List<T>>> fetch<T>({returnResult = false}) async {
    try {
      final response = await _dio.get(
        uri: _uri,
        returnResult: returnResult,
      );
      if (response.isRight) {
        final List<dynamic> results = response.right['results'];
        final List<$ModelClass$Model> itens = results.map((item) => $ModelClass$Model.fromMapGET(item)).toList();
        return Right(itens as List<T>);
      }
      return Left(Exception('Error fetching data, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error fetching data, error: $error'));
    }
  }

  @override
  Future<Either<Exception, List<T>>> getMore<T>({required String uri, returnResult = false}) async {
    try {
      final response = await _dio.get(
        uri: uri,
        returnResult: returnResult,
      );
      if (response.isRight) {
        final List<dynamic> results = response.right['results'];
        final List<$ModelClass$Model> itens = results.map((item) => $ModelClass$Model.fromMapGET(item)).toList();
        return Right(itens as List<T>);
      }
      return Left(Exception('Error fetching data, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error fetching data, error: $error'));
    }
  }

  @override
  Future<Either<Exception, T>> detail<T>({required String id}) async {
    try {
      final url = '$_uri$id/';
      final response = await _dio.get(uri: url, returnResult: true);
      if (response.isRight) {
        return Right(response.right);
      }
      return Left(Exception('Error fetching data, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error fetching data, error: $error'));
    }
  }

  @override
  Future<Either<Exception, T>> post<T>({required dynamic data, bool multipart = false}) async {
    try {
      final postData = json.encode(data.toMap());
      final response = await _dio.post(uri: _uri, data: postData, multipart: multipart);
      if (response.isRight) {
        final Map<String, dynamic> map = response.right;
        final $ModelClass$Model item = $ModelClass$Model.fromMap(map);
        return Right(item as T);
      }
      return Left(Exception('Error posting data, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error posting data, error: $error'));
    }
  }

  @override
  Future<Either<Exception, T>> put<T>({required dynamic data, bool multipart = false}) async {
    try {
      if (data.id == null) {
        return Left(Exception('ID not found in data'));
      }
      final url = '$_uri${data.id}';
      final postData = json.encode(data.toMap());
      final response = await _dio.put(uri: url, data: postData, multipart: multipart);
      if (response.isRight) {
        final Map<String, dynamic> map = response.right;
        final $ModelClass$Model item = $ModelClass$Model.fromMap(map);
        return Right(item as T);
      }
      return Left(Exception('Error updating data, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error updating data, error: $error'));
    }
  }

  @override
  Future<Either<Exception, T>> patch<T>({required dynamic data, bool multipart = false}) async {
    try {
      if (data.id == null) {
        return Left(Exception('ID not found in data'));
      }
      final url = '$_uri${data.id}';
      final postData = json.encode(data.toMap());
      final response = await _dio.patch(uri: url, data: postData, multipart: multipart);
      if (response.isRight) {
        final Map<String, dynamic> map = response.right;
        final $ModelClass$Model item = $ModelClass$Model.fromMap(map);
        return Right(item as T);
      }
      return Left(Exception('Error patching data, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error patching data, error: $error'));
    }
  }

  @override
  Future<Either<Exception, bool>> delete({required String id}) async {
    try {
      final response = await _dio.delete(uri: _uri, id: id);
      if (response.isRight) {
        return const Right(true);
      }
      return Left(Exception('Error deleting item, error: ${response.left}'));
    } catch (error) {
      return Left(Exception('Error deleting item, error: $error'));
    }
  }
}
